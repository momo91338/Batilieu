<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LibreWebChain P2P</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f0f0f0;
      padding: 20px;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .block, .balance {
      background: #eee;
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 6px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      margin-top: 10px;
      margin-right: 10px;
    }
    input {
      padding: 8px;
      margin: 4px;
      width: calc(100% - 16px);
    }
    #loginSection {
      margin-bottom: 20px;
      background: #fff3cd;
      padding: 10px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="loginSection">
      <h2>🔐 تسجيل / دخول</h2>
      <input type="text" id="username" placeholder="اسم المستخدم" />
      <button onclick="register()">📝 تسجيل جديد</button>
      <button onclick="login()">🚪 دخول</button>
    </div><div id="app" style="display:none;">
  <h1>🌐 LibreWebChain (P2P)</h1>
  <p><strong>🔐 مفتاحك العام:</strong></p>
  <p id="publicKey"></p>
  <button onclick="proveActivity()">✅ أثبت نشاطك</button>

  <h3>💸 إرسال عملة:</h3>
  <input type="text" id="toAddress" placeholder="إدخال عنوان المستقبل"/>
  <input type="number" id="amount" placeholder="قيمة المبلغ"/>
  <button onclick="sendTransaction()">📤 إرسال</button>

  <div class="balance" id="balanceDisplay"></div>

  <h3>📦 سلسلة الكتل:</h3>
  <div id="blockchain"></div>
</div>

  </div>  <script type="module">
    import { createLibp2p } from 'https://cdn.jsdelivr.net/npm/libp2p@0.43.0/dist/index.min.js';
    import { webRTC } from 'https://cdn.jsdelivr.net/npm/@libp2p/webrtc@5.1.1/dist/index.min.js';
    import { webSockets } from 'https://cdn.jsdelivr.net/npm/@libp2p/websockets@5.1.1/dist/index.min.js';
    import { noise } from 'https://cdn.jsdelivr.net/npm/@chainsafe/libp2p-noise@11.0.6/dist/index.min.js';
    import { mplex } from 'https://cdn.jsdelivr.net/npm/@libp2p/mplex@10.0.2/dist/index.min.js';
    import { kadDHT } from 'https://cdn.jsdelivr.net/npm/@libp2p/kad-dht@9.0.7/dist/index.min.js';

    let blockchain = [];
    let publicKey = '';
    let privateKey;
    let libp2p;
    let activeMiners = new Set();
    let balance = {}; 
    let pendingTransactions = [];

    async function generateKeys() {
      const keyPair = await crypto.subtle.generateKey(
        { name: 'ECDSA', namedCurve: 'P-256' },
        true,
        ['sign', 'verify']
      );
      privateKey = keyPair.privateKey;
      const spki = await crypto.subtle.exportKey('spki', keyPair.publicKey);
      publicKey = btoa(String.fromCharCode(...new Uint8Array(spki)));
    }

    function register() {
      const username = document.getElementById("username").value.trim();
      if (!username) return alert("⚠️ أدخل اسم مستخدم أولاً");
      generateKeys().then(() => {
        localStorage.setItem(`user-${username}`, publicKey);
        alert("✅ تم التسجيل بنجاح. يمكنك الآن الضغط على دخول.");
      });
    }

    function login() {
      const username = document.getElementById("username").value.trim();
      if (!username) return alert("⚠️ أدخل اسم المستخدم");
      const storedKey = localStorage.getItem(`user-${username}`);
      if (!storedKey) return alert("❌ المستخدم غير مسجل");
      publicKey = storedKey;
      document.getElementById("publicKey").innerText = publicKey.slice(0, 50) + '...';
      document.getElementById("loginSection").style.display = "none";
      document.getElementById("app").style.display = "block";
      startAfterLogin();
    }

    async function startAfterLogin() {
      await startP2P();
      renderBalance();
      setInterval(generateBlock, 10000);
    }

    async function sha256(data) {
      const encoder = new TextEncoder();
      const buffer = encoder.encode(data);
      const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
      return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function proveActivity() {
      activeMiners.add(publicKey);
    }

    async function generateBlock() {
      if (activeMiners.size === 0) return;
      const miners = Array.from(activeMiners);
      const selectedMiner = miners[Math.floor(Math.random() * miners.length)];

      const blockTransactions = [...pendingTransactions];
      pendingTransactions = [];

      const newBlock = {
        index: blockchain.length,
        timestamp: new Date().toISOString(),
        miner: selectedMiner,
        reward: 1000,
        transactions: blockTransactions,
        previousHash: blockchain.length === 0 ? '0' : blockchain[blockchain.length - 1].hash,
      };

      newBlock.hash = await sha256(JSON.stringify(newBlock));
      blockchain.push(newBlock);

      balance[selectedMiner] = (balance[selectedMiner] || 0) + newBlock.reward;
      for (let tx of blockTransactions) {
        balance[tx.from] = (balance[tx.from] || 0) - tx.amount;
        balance[tx.to] = (balance[tx.to] || 0) + tx.amount;
      }

      renderBlockchain();
      renderBalance();
      broadcastBlock(newBlock);
    }

    function sendTransaction() {
      const to = document.getElementById("toAddress").value.trim();
      const amount = parseInt(document.getElementById("amount").value.trim());
      if (!to || isNaN(amount) || amount <= 0) return alert("❗ تأكد من صحة البيانات");
      if ((balance[publicKey] || 0) < amount) return alert("❌ الرصيد غير كافٍ");

      const tx = { from: publicKey, to, amount };
      pendingTransactions.push(tx);
      broadcastTransaction(tx);
      alert("✅ تم إرسال المعاملة بنجاح")
    }

    function renderBlockchain() {
      const container = document.getElementById("blockchain");
      container.innerHTML = blockchain.map(block => `
        <div class="block">
          <strong>الكتلة #${block.index}</strong><br/>
          ⏱️ ${block.timestamp}<br/>
          👤 المعدّن: ${block.miner.slice(0, 20)}...<br/>
          💰 المكافأة: ${block.reward}<br/>
          🔗 Hash: ${block.hash.slice(0, 25)}...<br/>
          📄 معاملات:
          <ul>
            ${(block.transactions || []).map(tx => `
              <li>من ${tx.from.slice(0,10)}... إلى ${tx.to.slice(0,10)}... : ${tx.amount}</li>
            `).join('')}
          </ul>
        </div>
      `).join('');
    }

    function renderBalance() {
      const b = balance[publicKey] || 0;
      document.getElementById("balanceDisplay").innerHTML = `رصيدك: <strong>${b}</strong> عملة`;
    }

    async function broadcastBlock(block) {
      const message = new TextEncoder().encode(JSON.stringify({ type: 'block', data: block }));
      for (const stream of libp2p.getStreams()) {
        await stream.sink([message]);
      }
    }

    async function broadcastTransaction(tx) {
      const message = new TextEncoder().encode(JSON.stringify({ type: 'tx', data: tx }));
      for (const stream of libp2p.getStreams()) {
        await stream.sink([message]);
      }
    }

    async function startP2P() {
      libp2p = await createLibp2p({
        transports: [webRTC(), webSockets()],
        connectionEncryption: [noise()],
        streamMuxers: [mplex()],
        dht: kadDHT(),
      });

      libp2p.addEventListener('peer:connect', evt => {
        console.log('✅ متصل مع عقدة:', evt.detail.id.toString());
      });

      libp2p.addEventListener('peer:disconnect', evt => {
        console.log('❌ انقطع الاتصال مع:', evt.detail.id.toString());
      });

      await libp2p.start();

      libp2p.handle('/chain', async ({ stream }) => {
        for await (const msg of stream.source) {
          const str = new TextDecoder().decode(msg);
          const { type, data } = JSON.parse(str);
          if (type === 'block') {
            if (!blockchain.find(b => b.hash === data.hash)) {
              blockchain.push(data);
              balance[data.miner] = (balance[data.miner] || 0) + data.reward;
              for (let tx of data.transactions || []) {
                balance[tx.from] = (balance[tx.from] || 0) - tx.amount;
                balance[tx.to] = (balance[tx.to] || 0) + tx.amount;
              }
              renderBlockchain();
              renderBalance();
            }
          } else if (type === 'tx') {
            if (!pendingTransactions.find(t => t.from === data.from && t.to === data.to && t.amount === data.amount)) {
              pendingTransactions.push(data);
            }
          }
        }
      });
    }
  </script></body>
</html>
