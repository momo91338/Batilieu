<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <title>ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ Ù…Ø¹ Binance - BTC/USDC</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to right, #2c3e50, #3498db);
            color: white;
            text-align: center;
            padding: 20px;
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        p {
            font-size: 1.2em;
            margin-bottom: 20px;
        }
        button {
            background-color: #1abc9c;
            border: none;
            padding: 10px 20px;
            font-size: 1.1em;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        button:hover {
            background-color: #16a085;
        }
        canvas {
            max-width: 90%;
            background-color: white;
            border-radius: 10px;
            padding: 10px;
            margin-top: 20px;
        }
        #recommendation {
            font-size: 1.5em;
            margin-top: 20px;
            color: #f1c40f;
        }
    </style>
</head>
<body>
    <h1>ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ Ù…Ø¹ Binance</h1>
    <p>Ù‚Ø±Ø§Ø¡Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø¢Ø®Ø± 50 Ø´Ù…Ø¹Ø© (15 Ø¯Ù‚ÙŠÙ‚Ø©) Ù„Ø¹Ù…Ù„Ø© BTC/USDC</p>
    <button onclick="fetchData()">ØªØ­Ø¯ÙŠØ« ÙŠØ¯ÙˆÙŠ Ø§Ù„Ø¢Ù†</button>
    <h2 id="recommendation">ğŸ”„ Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„...</h2>
    <canvas id="chart"></canvas>

    <script>
        let chartInstance = null;

        async function fetchData() {
            try {
                const response = await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDC&interval=15m&limit=50');
                const data = await response.json();

                const closes = data.map(candle => parseFloat(candle[4]));
                const volumes = data.map(candle => parseFloat(candle[5]));

                analyze(closes, volumes);
            } catch (error) {
                document.getElementById('recommendation').innerText = "âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.";
                console.error(error);
            }
        }

        function analyze(closes, volumes) {
            const ma = closes.reduce((a, b) => a + b, 0) / closes.length;

            let gains = 0, losses = 0;
            for (let i = 1; i < closes.length; i++) {
                let diff = closes[i] - closes[i - 1];
                if (diff > 0) gains += diff;
                else losses -= diff;
            }

            const avgGain = gains / closes.length;
            const avgLoss = losses / closes.length;
            const rs = avgGain / (avgLoss || 1);
            const rsi = 100 - (100 / (1 + rs));

            let trend = 0;
            for (let i = 1; i < closes.length; i++) {
                if (closes[i] > closes[i - 1]) trend++;
                else if (closes[i] < closes[i - 1]) trend--;
            }

            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;

            let recommendation = "â¸ï¸ Ø§Ù†ØªØ¸Ø± (Ù„Ø§ Ø§ØªØ¬Ø§Ù‡ ÙˆØ§Ø¶Ø­)";
            if (trend >= closes.length * 0.7 && rsi < 70 && closes[closes.length - 1] > ma && volumes[volumes.length - 1] > avgVolume) {
                recommendation = "âœ… Ø§Ø´ØªØ±Ù (Ø§ØªØ¬Ø§Ù‡ ØµØ§Ø¹Ø¯)";
            } else if (trend <= -closes.length * 0.7 && rsi > 30 && closes[closes.length - 1] < ma && volumes[volumes.length - 1] > avgVolume) {
                recommendation = "ğŸ”» Ø¨Ø¹ (Ø§ØªØ¬Ø§Ù‡ Ù‡Ø§Ø¨Ø·)";
            }

            document.getElementById('recommendation').innerText = recommendation;

            // Ø±Ø³Ù… Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ
            const ctx = document.getElementById('chart').getContext('2d');
            if (chartInstance) chartInstance.destroy();
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: closes.map((_, i) => `Ø´Ù…Ø¹Ø© ${i + 1}`),
                    datasets: [
                        { label: 'Ø§Ù„Ø¥ØºÙ„Ø§Ù‚', data: closes, borderColor: 'blue', fill: false },
                        { label: 'MA', data: Array(closes.length).fill(ma), borderColor: 'orange', borderDash: [5, 5], fill: false }
                    ]
                },
                options: {
                    plugins: { legend: { position: 'top' } },
                    scales: { y: { beginAtZero: false } }
                }
            });
        }

        // Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø©
        fetchData(); // Ø£ÙˆÙ„ ØªØ­Ù…ÙŠÙ„ Ø¹Ù†Ø¯ Ø§Ù„ÙØªØ­
        setInterval(fetchData, 60000); // ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø©
    </script>
</body>
</html>
