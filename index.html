<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LibreWebChain P2P</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f0f0f0;
      padding: 20px;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .block, .balance {
      background: #eee;
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 6px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      margin-top: 10px;
      margin-right: 10px;
    }
    input {
      padding: 8px;
      margin: 4px;
      width: calc(100% - 16px);
    }
    #loginSection {
      margin-bottom: 20px;
      background: #fff3cd;
      padding: 10px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="loginSection">
      <h2>ğŸ” ØªØ³Ø¬ÙŠÙ„ / Ø¯Ø®ÙˆÙ„</h2>
      <input type="text" id="username" placeholder="Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" />
      <button onclick="register()">ğŸ“ ØªØ³Ø¬ÙŠÙ„ Ø¬Ø¯ÙŠØ¯</button>
      <button onclick="login()">ğŸšª Ø¯Ø®ÙˆÙ„</button>
    </div><div id="app" style="display:none;">
  <h1>ğŸŒ LibreWebChain (P2P)</h1>
  <p><strong>ğŸ” Ù…ÙØªØ§Ø­Ùƒ Ø§Ù„Ø¹Ø§Ù…:</strong></p>
  <p id="publicKey"></p>
  <button onclick="proveActivity()">âœ… Ø£Ø«Ø¨Øª Ù†Ø´Ø§Ø·Ùƒ</button>

  <h3>ğŸ’¸ Ø¥Ø±Ø³Ø§Ù„ Ø¹Ù…Ù„Ø©:</h3>
  <input type="text" id="toAddress" placeholder="Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„"/>
  <input type="number" id="amount" placeholder="Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø¨Ù„Øº"/>
  <button onclick="sendTransaction()">ğŸ“¤ Ø¥Ø±Ø³Ø§Ù„</button>

  <div class="balance" id="balanceDisplay"></div>

  <h3>ğŸ“¦ Ø³Ù„Ø³Ù„Ø© Ø§Ù„ÙƒØªÙ„:</h3>
  <div id="blockchain"></div>
</div>

  </div>  <script type="module">
    import { createLibp2p } from 'https://cdn.jsdelivr.net/npm/libp2p@0.43.0/dist/index.min.js';
    import { webRTC } from 'https://cdn.jsdelivr.net/npm/@libp2p/webrtc@5.1.1/dist/index.min.js';
    import { webSockets } from 'https://cdn.jsdelivr.net/npm/@libp2p/websockets@5.1.1/dist/index.min.js';
    import { noise } from 'https://cdn.jsdelivr.net/npm/@chainsafe/libp2p-noise@11.0.6/dist/index.min.js';
    import { mplex } from 'https://cdn.jsdelivr.net/npm/@libp2p/mplex@10.0.2/dist/index.min.js';
    import { kadDHT } from 'https://cdn.jsdelivr.net/npm/@libp2p/kad-dht@9.0.7/dist/index.min.js';

    let blockchain = [];
    let publicKey = '';
    let privateKey;
    let libp2p;
    let activeMiners = new Set();
    let balance = {}; 
    let pendingTransactions = [];

    async function generateKeys() {
      const keyPair = await crypto.subtle.generateKey(
        { name: 'ECDSA', namedCurve: 'P-256' },
        true,
        ['sign', 'verify']
      );
      privateKey = keyPair.privateKey;
      const spki = await crypto.subtle.exportKey('spki', keyPair.publicKey);
      publicKey = btoa(String.fromCharCode(...new Uint8Array(spki)));
    }

    function register() {
      const username = document.getElementById("username").value.trim();
      if (!username) return alert("âš ï¸ Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹");
      generateKeys().then(() => {
        localStorage.setItem(`user-${username}`, publicKey);
        alert("âœ… ØªÙ… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø¯Ø®ÙˆÙ„.");
      });
    }

    function login() {
      const username = document.getElementById("username").value.trim();
      if (!username) return alert("âš ï¸ Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…");
      const storedKey = localStorage.getItem(`user-${username}`);
      if (!storedKey) return alert("âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø³Ø¬Ù„");
      publicKey = storedKey;
      document.getElementById("publicKey").innerText = publicKey.slice(0, 50) + '...';
      document.getElementById("loginSection").style.display = "none";
      document.getElementById("app").style.display = "block";
      startAfterLogin();
    }

    async function startAfterLogin() {
      await startP2P();
      renderBalance();
      setInterval(generateBlock, 10000);
    }

    async function sha256(data) {
      const encoder = new TextEncoder();
      const buffer = encoder.encode(data);
      const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
      return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function proveActivity() {
      activeMiners.add(publicKey);
    }

    async function generateBlock() {
      if (activeMiners.size === 0) return;
      const miners = Array.from(activeMiners);
      const selectedMiner = miners[Math.floor(Math.random() * miners.length)];

      const blockTransactions = [...pendingTransactions];
      pendingTransactions = [];

      const newBlock = {
        index: blockchain.length,
        timestamp: new Date().toISOString(),
        miner: selectedMiner,
        reward: 1000,
        transactions: blockTransactions,
        previousHash: blockchain.length === 0 ? '0' : blockchain[blockchain.length - 1].hash,
      };

      newBlock.hash = await sha256(JSON.stringify(newBlock));
      blockchain.push(newBlock);

      balance[selectedMiner] = (balance[selectedMiner] || 0) + newBlock.reward;
      for (let tx of blockTransactions) {
        balance[tx.from] = (balance[tx.from] || 0) - tx.amount;
        balance[tx.to] = (balance[tx.to] || 0) + tx.amount;
      }

      renderBlockchain();
      renderBalance();
      broadcastBlock(newBlock);
    }

    function sendTransaction() {
      const to = document.getElementById("toAddress").value.trim();
      const amount = parseInt(document.getElementById("amount").value.trim());
      if (!to || isNaN(amount) || amount <= 0) return alert("â— ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª");
      if ((balance[publicKey] || 0) < amount) return alert("âŒ Ø§Ù„Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ");

      const tx = { from: publicKey, to, amount };
      pendingTransactions.push(tx);
      broadcastTransaction(tx);
      alert("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­")
    }

    function renderBlockchain() {
      const container = document.getElementById("blockchain");
      container.innerHTML = blockchain.map(block => `
        <div class="block">
          <strong>Ø§Ù„ÙƒØªÙ„Ø© #${block.index}</strong><br/>
          â±ï¸ ${block.timestamp}<br/>
          ğŸ‘¤ Ø§Ù„Ù…Ø¹Ø¯Ù‘Ù†: ${block.miner.slice(0, 20)}...<br/>
          ğŸ’° Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©: ${block.reward}<br/>
          ğŸ”— Hash: ${block.hash.slice(0, 25)}...<br/>
          ğŸ“„ Ù…Ø¹Ø§Ù…Ù„Ø§Øª:
          <ul>
            ${(block.transactions || []).map(tx => `
              <li>Ù…Ù† ${tx.from.slice(0,10)}... Ø¥Ù„Ù‰ ${tx.to.slice(0,10)}... : ${tx.amount}</li>
            `).join('')}
          </ul>
        </div>
      `).join('');
    }

    function renderBalance() {
      const b = balance[publicKey] || 0;
      document.getElementById("balanceDisplay").innerHTML = `Ø±ØµÙŠØ¯Ùƒ: <strong>${b}</strong> Ø¹Ù…Ù„Ø©`;
    }

    async function broadcastBlock(block) {
      const message = new TextEncoder().encode(JSON.stringify({ type: 'block', data: block }));
      for (const stream of libp2p.getStreams()) {
        await stream.sink([message]);
      }
    }

    async function broadcastTransaction(tx) {
      const message = new TextEncoder().encode(JSON.stringify({ type: 'tx', data: tx }));
      for (const stream of libp2p.getStreams()) {
        await stream.sink([message]);
      }
    }

    async function startP2P() {
      libp2p = await createLibp2p({
        transports: [webRTC(), webSockets()],
        connectionEncryption: [noise()],
        streamMuxers: [mplex()],
        dht: kadDHT(),
      });

      libp2p.addEventListener('peer:connect', evt => {
        console.log('âœ… Ù…ØªØµÙ„ Ù…Ø¹ Ø¹Ù‚Ø¯Ø©:', evt.detail.id.toString());
      });

      libp2p.addEventListener('peer:disconnect', evt => {
        console.log('âŒ Ø§Ù†Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ø¹:', evt.detail.id.toString());
      });

      await libp2p.start();

      libp2p.handle('/chain', async ({ stream }) => {
        for await (const msg of stream.source) {
          const str = new TextDecoder().decode(msg);
          const { type, data } = JSON.parse(str);
          if (type === 'block') {
            if (!blockchain.find(b => b.hash === data.hash)) {
              blockchain.push(data);
              balance[data.miner] = (balance[data.miner] || 0) + data.reward;
              for (let tx of data.transactions || []) {
                balance[tx.from] = (balance[tx.from] || 0) - tx.amount;
                balance[tx.to] = (balance[tx.to] || 0) + tx.amount;
              }
              renderBlockchain();
              renderBalance();
            }
          } else if (type === 'tx') {
            if (!pendingTransactions.find(t => t.from === data.from && t.to === data.to && t.amount === data.amount)) {
              pendingTransactions.push(data);
            }
          }
        }
      });
    }
  </script></body>
</html>
