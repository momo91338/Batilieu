<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <title>ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ Ù…Ø¹ Binance - Ø¥Ø´Ø§Ø±Ø§Øª Ù†ØµÙŠØ©</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial; background: linear-gradient(to right, #2c3e50, #3498db); color: white; text-align: center; padding: 20px; }
        h1 { font-size: 2.5em; }
        select, button { padding: 10px; margin: 10px; border-radius: 5px; border: none; }
        button { background-color: #1abc9c; color: white; cursor: pointer; }
        canvas { width: 100% !important; height: 600px !important; background-color: white; border-radius: 10px; padding: 10px; margin: 20px auto; display: block; }
        #recommendation { font-size: 1.8em; margin-top: 20px; }
    </style>
</head>
<body>
    <h1>ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ Ù…Ø¹ Binance</h1>
    <p>Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„Ø© ÙˆØ§Ù„ÙØ±ÙŠÙ…:</p>
    <select id="symbolSelect">
        <option value="BTCUSDC">BTC/USDC</option>
        <option value="DOGEUSDC">DOGE/USDC</option>
    </select>
    <select id="timeframeSelect">
        <option value="1m">1 Ø¯Ù‚ÙŠÙ‚Ø©</option>
        <option value="5m" selected>5 Ø¯Ù‚Ø§Ø¦Ù‚</option>
        <option value="15m">15 Ø¯Ù‚ÙŠÙ‚Ø©</option>
        <option value="1h">1 Ø³Ø§Ø¹Ø©</option>
    </select>
    <br>
    <button onclick="fetchData()">ØªØ­Ø¯ÙŠØ« ÙŠØ¯ÙˆÙŠ</button>
    <h2 id="recommendation">ğŸ”„ Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„...</h2>
    <canvas id="chart"></canvas>
    <audio id="alertSound" src="https://www.soundjay.com/button/beep-07.wav" preload="auto"></audio>

    <script>
        let chartInstance = null;
        let lastRecommendation = "";
        let buySignalsGlobal = [];
        let sellSignalsGlobal = [];

        async function fetchData() {
            try {
                const symbol = document.getElementById("symbolSelect").value;
                const interval = document.getElementById("timeframeSelect").value;
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=50`);
                const data = await response.json();

                const closes = data.map(c => parseFloat(c[4]));
                const highs = data.map(c => parseFloat(c[2]));
                const lows = data.map(c => parseFloat(c[3]));
                const volumes = data.map(c => parseFloat(c[5]));

                analyze(closes, highs, lows, volumes, symbol);
            } catch (error) {
                document.getElementById('recommendation').innerText = "âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.";
                console.error(error);
            }
        }

        function analyze(closes, highs, lows, volumes, symbol) {
            const ma = closes.reduce((a, b) => a + b) / closes.length;

            const ema = (data, period) => {
                const k = 2 / (period + 1);
                let emaArray = [data[0]];
                for (let i = 1; i < data.length; i++) {
                    emaArray.push((data[i] * k) + (emaArray[i - 1] * (1 - k)));
                }
                return emaArray;
            };
            const ema12 = ema(closes, 12);
            const ema26 = ema(closes, 26);
            const macd = ema12.map((v, i) => v - ema26[i]);

            const period = 20;
            const slice = closes.slice(-period);
            const bbMa = slice.reduce((a, b) => a + b) / period;
            const stdDev = Math.sqrt(slice.reduce((a, b) => a + Math.pow(b - bbMa, 2), 0) / period);
            const upper = bbMa + (2 * stdDev);
            const lower = bbMa - (2 * stdDev);

            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            for (let i = 0; i < closes.length; i++) {
                const xLabel = `Ø´Ù…Ø¹Ø© ${i + 1}`;
                const isBuyExist = buySignalsGlobal.find(p => p.x === xLabel);
                const isSellExist = sellSignalsGlobal.find(p => p.x === xLabel);
                if (macd[i] > 0 && closes[i] > upper && !isBuyExist) {
                    buySignalsGlobal.push({ x: xLabel, y: closes[i], index: i });
                } else if (macd[i] < 0 && closes[i] < lower && !isSellExist) {
                    sellSignalsGlobal.push({ x: xLabel, y: closes[i], index: i });
                }
            }

            let recommendation = "â¸ï¸ Ø§Ù†ØªØ¸Ø± (Ù„Ø§ Ø§ØªØ¬Ø§Ù‡ ÙˆØ§Ø¶Ø­)";
            let color = "#f1c40f";
            if (buySignalsGlobal.length > 0) {
                recommendation = "âœ… Ø§Ø´ØªØ±Ù (" + symbol + ")";
                color = "lime";
            } else if (sellSignalsGlobal.length > 0) {
                recommendation = "ğŸ”» Ø¨Ø¹ (" + symbol + ")";
                color = "red";
            }

            document.getElementById('recommendation').innerText = recommendation;
            document.getElementById('recommendation').style.color = color;

            if (recommendation !== lastRecommendation && (recommendation.includes("Ø§Ø´ØªØ±Ù") || recommendation.includes("Ø¨Ø¹"))) {
                document.getElementById('alertSound').play();
            }
            lastRecommendation = recommendation;

            const ctx = document.getElementById('chart').getContext('2d');
            if (chartInstance) chartInstance.destroy();
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: closes.map((_, i) => `Ø´Ù…Ø¹Ø© ${i + 1}`),
                    datasets: [
                        { label: 'Ø§Ù„Ø¥ØºÙ„Ø§Ù‚', data: closes, borderColor: 'blue', fill: false },
                        { label: 'MA', data: Array(closes.length).fill(ma), borderColor: 'orange', borderDash: [5,5], fill: false },
                        { label: 'Bollinger Upper', data: Array(closes.length).fill(upper), borderColor: 'green', borderDash: [2,2], fill: false },
                        { label: 'Bollinger Lower', data: Array(closes.length).fill(lower), borderColor: 'red', borderDash: [2,2], fill: false }
                    ]
                },
                options: {
                    plugins: {
                        legend: { position: 'top' },
                        annotation: {
                            annotations: [
                                ...buySignalsGlobal.map(p => ({
                                    type: 'label',
                                    xValue: p.index,
                                    yValue: p.y,
                                    backgroundColor: 'lime',
                                    content: ['BUY'],
                                    font: { size: 14, weight: 'bold' },
                                    color: 'black'
                                })),
                                ...sellSignalsGlobal.map(p => ({
                                    type: 'label',
                                    xValue: p.index,
                                    yValue: p.y,
                                    backgroundColor: 'red',
                                    content: ['SELL'],
                                    font: { size: 14, weight: 'bold' },
                                    color: 'white'
                                }))
                            ]
                        }
                    },
                    scales: { y: { beginAtZero: false } }
                }
            });
        }

        fetchData();
        setInterval(fetchData, 60000);
    </script>
</body>
</html>
